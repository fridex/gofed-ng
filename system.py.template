#!/bin/python
# -*- coding: utf-8 -*-
# ####################################################################
# gofed-ng - Golang system
# Copyright (C) 2016  Fridolin Pokorny, fpokorny@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# ####################################################################

from common.registry.registryClient import RegistryClient
from common.helpers.output import log
from rpyc.utils.registry import REGISTRY_PORT
from plumbum import SshMachine
import rpyc
import random

DEFAULT_SERVICE_PORT = 18812

class System(object):
	def __init__(self, config):
		self.config = config
{% for service in param %}{% if service['type'] == 'class' %}
		self.{{ service['name'] }} = None
{%endif%}{% endfor %}

	def _parse_bool(self, s):
		if s not in [ 'True', 'False' ]:
			raise ValueError("Unknown boolean value '%s' in config" % s)
		return s == 'True'


	def _parse_service_section(self, service):
		def _service_section_check(s):
			if not s['remote'] and s['ssh']:
				raise ValueError("ssh defined but remote is disabled at the same time in section %s", service)

		ret = { 'remote': False, 'ssh': False, 'host': None, 'port': DEFAULT_SERVICE_PORT }

		if service in self.config.sections():
			for opt in self.config.items(service):
				if opt[0] == 'remote':
					ret['remote'] = self._parse_bool(opt[1])

				if opt[0] == "ssh":
					ret['ssh'] = self._parse_bool(opt[1])

				if opt[0] == "host":
					ret['host'] = opt[1]

				if opt[0] == "port":
					ret['port'] = opt[1]

		_service_section_check(ret)
		return ret

	def _get_service_location(self, service_name):
		service = RegistryClient.query(service_name)

		if len(service) < 1:
			raise Exception("Service not found in Registry")

		idx = int(random.random() * len(service)) # try to do load balancing if possible
		return service[idx]

{% for service in param %}{% for action in service['defs'] %}
	def {{ action["name"] }}(self{% for arg in action["args"] %}, {{ arg }}{% endfor %}):
		def local_call():
{% if service['type'] == 'class' %}
			try:
				from services.{{ service["name"] }}.exposed import {{ service["class"] }}
			except ImportError:
				log.print_error("Failed to import local service '{{ service['name'] }}' to do action '{{ action['name'] }}'")
			if self.{{ service["name"] }} == None:
				if "{{service['name']}}" in self.config.sections():
					self.{{ service["name"] }} = {{ service["class"] }}(self.config.items("{{service['name']}}"))
				else:
					self.{{ service["name"] }} = {{ service["class"] }}()
			return self.{{ service["name"] }}.exposed_{{ action["name"] }}({% for arg in action["args"][:-1] %}{{ arg }},{% endfor %}{{ action["args"][-1] }})
{% else %}
			try:
				from services.{{ service["name"] }}.exposed import {{ action["name"] }}
			except ImportError:
				log.print_error("Failed to import local service %s to do action %s" % (service['name'], action['name']))
			return exposed_{{ action["name"] }}({% for arg in action["args"][:-1] %}{{ arg }},{% endfor %}{{ action["args"][-1] }})
{% endif %}

		def remote_rpc_call(host, port):
			conn = rpyc.connect(host, port)
			return conn.root.{{ action["name"] }}({% for arg in action["args"][:-1] %}{{ arg }},{% endfor %}{{ action["args"][-1] }})

		def remote_ssh_call(host, port):
			sshctx = SshMachine(host) # TODO: add keys to config
			conn = rpyc.ssh_connect(sshctx, port)
			return conn.root.{{ action["name"] }}({% for arg in action["args"][:-1] %}{{ arg }},{% endfor %}{{ action["args"][-1] }})


		cnf = self._parse_service_section("{{ service['name'] }}")

		if cnf['remote'] is True:
			if not cnf['host']:
				loc = self._get_service_location("{{ service['name'] }}")
				cnf['host'] = loc[0]
				cnf['port'] = loc[1]

			if cnf['ssh'] is True:
				return remote_ssh_call(cnf['host'], cnf['port'])
			else:
				return remote_rpc_call(cnf['host'], cnf['port'])
		else:
			return local_call()
{% endfor %}{% endfor %}

