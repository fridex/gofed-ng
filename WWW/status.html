<h2>Current System Status</h2>

<div class="modal fade" id="system-status" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">Ã—</span></button>
        <h4 class="modal-title" id="myModalLabel">System status meta-info</h4>
      </div>
      <div id="system-status-info" class="modal-body"><dl class="dl-horizontal"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<div id="current-status" class="text-center"></div>

<button type="button" style="display: block" class="btn pull-right" data-toggle="modal" data-target="#system-status">View status.json meta-info</button>

<script src="js/d3.min.js"></script>
<script>
jQuery(function($) {

function print_json_info(json) {
      $('#system-status-info').append($(
'<dl class="dl-horizontal">' +
'  <dt>Generated by</dt>' +
'  <dd>' + json['author'] + '</dd>' +
'  <dt>Generated on</dt>' +
'  <dd>' + json['hostname'] + '</dd>' +
'  <dt>Generated</dt>' +
'  <dd>' + json['generated'] + '</dd>' +
'  <dt>gofed version</dt>' +
'  <dd>' + json['gofed_version'] + '</dd>' +
'  <dt>Raw</dt>' +
'  <dd><a href="status.json">status.json</a></dd>' +
'</dl>'
      ));
}

function print_graph(links) {
  var nodes = {};
  links.forEach(function(link) {
    if (link.type == 'registry') {
      if (nodes['registry'] == undefined)
        nodes['registry'] = {name: 'registry'};
      link.source = nodes['registry'];
      link.source.host = link.host;
      link.source.type = link.type;
      link.source.port = link.port;
      link.target = nodes['registry'];
    } else { // host
      link.source = nodes[link.service] || (nodes[link.service] = {name: link.service});
      link.source.port = link.port;
      link.source.type = link.type;
      link.source.host = link.host;

      link.target = nodes[link.host] || (nodes[link.host] = {name: link.host});
      link.target.type = 'host';
      links.push({ source: link.target,
                   target: nodes['registry'] || (nodes['registry'] = {name: 'registry'})
      });
    }
  });

  // TODO: make it responsible
  var width = 800,
      height = 600;

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(120)
      .charge(-300)
      .on("tick", tick)
      .start();

  var svg = d3.select("#current-status").append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("class", "img-thumbnail");

  var link = svg.selectAll(".link")
      .data(force.links())
      .enter().append("line")
      .attr("style", "fill: none; stroke: #666; stroke-width: 1.5px;");

  var node = svg.selectAll(".node")
      .data(force.nodes())
      .enter().append("g")
      .attr("class", "node")
      .call(force.drag);

  var tooltip = d3.select("#current-status")
     .append("div")
     .style("position", "absolute")
     .style("z-index", "10")
     .attr("class", "alert alert-info")
     .style("visibility", "hidden");

  function get_node_img(d) {
    if (d.type == 'computational')
      return "img/computational.png";
    else if (d.type == 'storage')
      return "img/storage.png";
    else if (d.type == 'host')
      return "img/host.png";
    else // storage, no source node
      return "img/system.png";
  }

  function tooltip_show() {
    return tooltip.style("visibility", "visible");
  }

  function tooltip_fill(d) {
    if (d.type == 'computational') {
      tooltip.text("A computational service with name '" + d.name + "' running on port " + d.port);
    } else if (d.type == 'storage') {
      tooltip.text("A storage service with name '" + d.name + "' running on port " + d.port);
    } else if (d.type == 'host') {
      tooltip.text("A host running on " + d.name);
    } else if (d.type == 'registry') {
      tooltip.text("Registry " + d.host + ':' + d.port);
    }

    left_offset = $('#current-status').offset().left;
    top_offset = $('#current-status').offset().top;

    return tooltip.style("top", (d3.event.pageY - top_offset)+"px").style("left", (d3.event.pageX -  left_offset)+"px");
  }

  function tooltip_hide() {
    return tooltip.style("visibility", "hidden");
  }

  node.append("image")
      .attr("class", function (d) {
          return "node " + d.id;
          })
      .attr("xlink:href", get_node_img)
      .attr("width", "32px")
      .attr("height", "32px")
      .on("mouseover", tooltip_show)
      .on("mousemove", function(d, a) { return tooltip_fill(d); })
      .on("mouseout", tooltip_hide);

  node.append("text")
      .attr("x", "5")
      .attr("dy", "-10")
      .text(function(d) { return d.name; });

  function tick() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }
}

var json = (function () {
  var json = null;
  $.ajax({
    'url': 'status.json',
    'dataType': "json",
    'success': function (data) {
      print_graph(data['topology']);
      print_json_info(data);
    },
    'error': function (e, status, error) {
      alert('Failed to download status.json: ' + error);
    }
  });
})();

});

</script>
